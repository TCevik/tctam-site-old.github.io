<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TC_tam Lichtsimulatie</title>
    <link rel="stylesheet" href="/style.css">
    <script src="/script.js"></script>

    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0;
            height: 100vh;
            overflow-y: hidden;
        }

        canvas {
            border: 1px solid black;
            background-color: white;
        }
    </style>
</head>

<body>
    <canvas id="dotsCanvas" width="600" height="600"></canvas>
    <div style="margin-left: 20px;">
        <p>Klik op 2 stippen om daar tussen lijnen te maken.</p>
        <p id="reflectionCount">Aantal reflecties:</p>
        <button id="undoButton">Undo</button>

        <div id="typeLineOptions">
            <label>
                <input type="radio" name="typeLine" value="spiegel" checked>
                Spiegel
            </label>
            <br><label style="margin-left: 10px;">
                <input type="radio" name="typeLine" value="laser">
                Laser
            </label>
        </div>

        <br>
        <br><button onclick="window.location.reload()">Maak Leeg</button>
        <br>
        <br>
        <!-- Display Advertisement Start  -->
        <script async
            src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8924607946192862"
            crossorigin="anonymous"></script>
        <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-8924607946192862"
            data-ad-slot="5862330293" data-ad-format="auto" data-full-width-responsive="true"></ins>
        <script>
            (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
        <!-- Advertisement End -->
    </div>
    <script>
        let typeLine = "spiegel";

        const radioButtons = document.querySelectorAll('input[name="typeLine"]');
        radioButtons.forEach(radio => {
            radio.addEventListener("change", (event) => {
                typeLine = event.target.value;
                notification('Je maakt nu een ' + typeLine + '.');
            });
        });

        const canvas = document.getElementById("dotsCanvas");
        const ctx = canvas.getContext("2d");
        const undoButton = document.getElementById("undoButton");

        const gridSize = 30;
        const dotRadius = 5;
        const margin = 10;

        const dots = [];
        const selectedDots = [];
        const lines = [];
        const laserLines = [];

        const spacing = (canvas.width - 2 * margin) / (gridSize - 1);

        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (const dot of dots) {
                ctx.beginPath();
                ctx.arc(dot.x, dot.y, dotRadius, 0, Math.PI * 2);
                ctx.fillStyle = "#bfbfbf";
                ctx.fill();
                ctx.closePath();
            }

            for (const line of lines) {
                if (line.color === "#000") {
                    ctx.beginPath();
                    ctx.moveTo(line.start.x, line.start.y);
                    ctx.lineTo(line.end.x, line.end.y);
                    ctx.strokeStyle = "#000";
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    ctx.closePath();
                }
            }

            for (const line of laserLines) {
                if (line.color !== "#000") {
                    ctx.beginPath();
                    ctx.moveTo(line.start.x, line.start.y);
                    ctx.lineTo(line.end.x, line.end.y);
                    ctx.strokeStyle = line.color || "red";
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                    ctx.closePath();
                }
            }

            for (const dot of selectedDots) {
                ctx.beginPath();
                ctx.arc(dot.x, dot.y, dotRadius, 0, Math.PI * 2);
                ctx.fillStyle = "#000";
                ctx.fill();
                ctx.closePath();
            }
        }

        for (let i = 0; i < gridSize; i++) {
            for (let j = 0; j < gridSize; j++) {
                const x = margin + i * spacing;
                const y = margin + j * spacing;
                dots.push({ x, y });
            }
        }

        const reflectionCountElement = document.getElementById("reflectionCount");

        let currentPoint = null;

        canvas.addEventListener("click", (event) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            const clickedDot = dots.find(dot => {
                const dx = dot.x - mouseX;
                const dy = dot.y - mouseY;
                return Math.sqrt(dx * dx + dy * dy) <= dotRadius * 2.5;
            });

            if (!clickedDot) return;

            if (typeLine === "spiegel") {
                if (!currentPoint) {
                    currentPoint = clickedDot;
                } else {
                    if (currentPoint !== clickedDot) {
                        const newLine = { start: currentPoint, end: clickedDot, color: "#000" };
                        let intersects = false;

                        for (const line of lines) {
                            if (line.color === "#000") {
                                const intersection = findIntersection(
                                    newLine.start, newLine.end,
                                    line.start, line.end
                                );

                                if (intersection && !(
                                    (intersection.x === newLine.start.x && intersection.y === newLine.start.y) ||
                                    (intersection.x === newLine.end.x && intersection.y === newLine.end.y) ||
                                    (intersection.x === line.start.x && intersection.y === line.start.y) ||
                                    (intersection.x === line.end.x && intersection.y === line.end.y)
                                )) {
                                    intersects = true;
                                    break;
                                }
                            }
                        }

                        if (intersects) {
                            notification("âŒ Spiegels mogen elkaar niet snijden!");
                        } else {
                            lines.push(newLine);
                            currentPoint = clickedDot;
                        }
                    }
                    drawGrid();
                }
            } else if (typeLine === "laser") {
                const alreadySelected = selectedDots.some(dot => dot.x === clickedDot.x && dot.y === clickedDot.y);

                if (!alreadySelected) {
                    selectedDots.push(clickedDot);

                    if (selectedDots.length === 2) {
                        const [dot1, dot2] = selectedDots;

                        let currentX = dot1.x;
                        let currentY = dot1.y;

                        let dx = dot2.x - dot1.x;
                        let dy = dot2.y - dot1.y;
                        const length = Math.sqrt(dx ** 2 + dy ** 2);
                        dx /= length;
                        dy /= length;

                        let reflections = 0;
                        const maxReflections = 250000;
                        laserLines.length = 0;

                        let lastHitLine = null;

                        while (reflections < maxReflections) {
                            let closestIntersection = null;
                            let closestLine = null;
                            let minDistance = Infinity;

                            for (const line of lines) {
                                if (line.color === "#000" && line !== lastHitLine) {
                                    const intersection = findIntersection(
                                        { x: currentX, y: currentY },
                                        { x: currentX + dx * 1000, y: currentY + dy * 1000 },
                                        line.start,
                                        line.end
                                    );

                                    if (intersection) {
                                        const dist = Math.sqrt(
                                            (intersection.x - currentX) ** 2 +
                                            (intersection.y - currentY) ** 2
                                        );

                                        if (dist < minDistance) {
                                            minDistance = dist;
                                            closestIntersection = intersection;
                                            closestLine = line;
                                        }
                                    }
                                }
                            }

                            if (closestIntersection) {
                                laserLines.push({
                                    start: { x: currentX, y: currentY },
                                    end: closestIntersection,
                                    color: "red"
                                });

                                const normal = {
                                    x: closestLine.end.y - closestLine.start.y,
                                    y: closestLine.start.x - closestLine.end.x
                                };

                                const reflection = calculateReflection(
                                    { x: currentX, y: currentY },
                                    closestIntersection,
                                    normal
                                );

                                lastHitLine = closestLine;

                                dx = reflection.x;
                                dy = reflection.y;

                                currentX = closestIntersection.x;
                                currentY = closestIntersection.y;
                                reflections++;
                                reflectionCountElement.textContent = `Aantal reflecties: ${reflections}`;
                            } else {
                                laserLines.push({
                                    start: { x: currentX, y: currentY },
                                    end: { x: currentX + dx * 1000, y: currentY + dy * 1000 },
                                    color: "red"
                                });
                                reflectionCountElement.textContent = `Aantal reflecties: ${reflections}`;
                                break;
                            }
                        }

                        selectedDots.length = 0;

                        if (reflections >= maxReflections) {
                            notification("ONGELDIG: De laser heeft de rand niet bereikt na 250.000 reflecties.");
                        }
                    }
                    drawGrid();
                }
            }
        });

        function findIntersection(p1, p2, p3, p4) {
            const s1_x = p2.x - p1.x;
            const s1_y = p2.y - p1.y;
            const s2_x = p4.x - p3.x;
            const s2_y = p4.y - p3.y;

            const denom = (-s2_x * s1_y + s1_x * s2_y);
            if (denom === 0) return null;

            const s = (-s1_y * (p1.x - p3.x) + s1_x * (p1.y - p3.y)) / denom;
            const t = (s2_x * (p1.y - p3.y) - s2_y * (p1.x - p3.x)) / denom;

            if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
                return {
                    x: p1.x + (t * s1_x),
                    y: p1.y + (t * s1_y)
                };
            }

            return null;
        }

        function calculateReflection(start, end, normal) {
            const incidentX = end.x - start.x;
            const incidentY = end.y - start.y;
            const incidentLength = Math.sqrt(incidentX ** 2 + incidentY ** 2);
            const incident = { x: incidentX / incidentLength, y: incidentY / incidentLength };

            const normalLength = Math.sqrt(normal.x ** 2 + normal.y ** 2);
            const unitNormal = { x: normal.x / normalLength, y: normal.y / normalLength };

            const dotProduct = incident.x * unitNormal.x + incident.y * unitNormal.y;
            const reflection = {
                x: incident.x - 2 * dotProduct * unitNormal.x,
                y: incident.y - 2 * dotProduct * unitNormal.y
            };

            return reflection;
        }

        function isPointOnLine(point, line) {
            const tolerance = 1;
            const { x, y } = point;
            const { start, end } = line;

            const crossProduct = Math.abs((y - start.y) * (end.x - start.x) - (x - start.x) * (end.y - start.y));
            const distance = Math.sqrt((end.x - start.x) ** 2 + (end.y - start.y) ** 2);

            return crossProduct / distance < tolerance &&
                x >= Math.min(start.x, end.x) && x <= Math.max(start.x, end.x) &&
                y >= Math.min(start.y, end.y) && y <= Math.max(start.y, end.y);
        }

        undoButton.addEventListener("click", () => {
            if (lines.length > 0) {
                lines.pop();

                if (lines.length > 0) {
                    const lastLine = lines[lines.length - 1];
                    currentPoint = lastLine.end;
                } else {
                    currentPoint = null;
                }

                drawGrid();
            }
        });

        document.addEventListener("keydown", (event) => {
            if (event.ctrlKey && event.key === 'z') {
                if (lines.length > 0) {
                    lines.pop();

                    if (lines.length > 0) {
                        const lastLine = lines[lines.length - 1];
                        currentPoint = lastLine.end;
                    } else {
                        currentPoint = null;
                    }

                    drawGrid();
                }
            }
        });

        drawGrid();

        function checkScreenWidth() {
            if (window.innerWidth < 1100) {
                alert("Gebruik een scherm breder dan 1100px om de applicatie te gebruiken.")
                window.location.href = "/";
            }
        }
        window.onload = checkScreenWidth;
    </script>
</body>

</html>